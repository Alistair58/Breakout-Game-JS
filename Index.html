<html>
<head>
 <meta charset="utf-8"/>
 <title>Breakout Game</title>
 <style>
    .buttonBig {width: 50%;font-size:30px;background-color:red;cursor:pointer;}
    * {padding: 0;margin:0;font-family:"Lucida Console";transition-duration: 0.4s;}
    .buttonBig:hover{background-color:white;border-color:red;}
    canvas { background: #eee; display: block; margin: 0 auto; }
 </style>
</head>
<body>
<br>
<center><h2 style="font-family:Lucida Console" id="startText">Press START to begin</h2>
<button class="button buttonBig" id="Btn" onclick="draw();">START</button></center>
<canvas id="myCanvas" width="480" height="320">
</canvas>

<script>
 var canvas = document.getElementById("myCanvas"); //Testing
 var ctx = canvas.getContext("2d");
 var ballRadius = 10;
 var speed = 10;
 var paddleHeight = 10;
 var paddleWidth = 75;
 var paddleX = (canvas.width-paddleWidth) / 2;
 var paddleY = (canvas.height-paddleHeight);
 var rightPressed = false;
 var leftPressed = false;
 var brickRowCount = 3;
 var brickColumnCount = 5;
 var brickWidth = 75;
 var brickHeight = 20;
 var brickPadding = 10;
 var brickOffsetTop = 30;
 var brickOffsetLeft = 30;
 var score = 0;
 var lives = 3;
 let x = canvas.width/2;
 let y = canvas.height-30;
 let dx = 2;
 let dy = -2;

 var bricks = []; //list of bricks
 for(var c=0; c<brickColumnCount; c++) { //c is like an iteration variable in python. It increments by 1 on each loop. Loop ends when c >= column count.
    bricks[c] = []; // Creates a 2d array. Each column has its own list
    for(var r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y:0, status:1 }; //status 1 means the brick hasn't been destroyed
    }
 }
 
 document.addEventListener("keydown", keyDownHandler, false);
 document.addEventListener("keyup", keyUpHandler, false);
 document.addEventListener("mousemove", mouseMoveHandler, false);
 Btn = document.getElementById("Btn")
 const startText = document.getElementById("startText")
 Btn.addEventListener("click", () => {
    Btn.style.visibility = "hidden";
    startText.style.visibility = "hidden";
 });

 
 

 function keyDownHandler(pressed) {
    if(pressed.key == "Right" || pressed.key == "ArrowRight") {
        rightPressed = true;
    }
    else if(pressed.key == "Left" || pressed.key == "ArrowLeft") {
        leftPressed = true;
    }
 }

 function keyUpHandler(notPressed) {
    if(notPressed.key == "Right" || notPressed.key == "ArrowRight") {
        rightPressed = false;
    }
    else if(notPressed.key == "Left" || notPressed.key == "ArrowLeft") {
        leftPressed = false;
    }
 }

 function mouseMoveHandler(e) {
    var relativeX = e.clientX - canvas.offsetLeft; //Distance from left edge
    if(relativeX > 0 && relativeX < canvas.width) { //If the mouse is in the canvas
        paddleX = relativeX - paddleWidth/2; //paddle location is set to mouse location
    }
 }

 

 function collisionDetection() {
    for(var c=0; c<brickColumnCount; c++){
        for(var r=0; r<brickRowCount; r++){ //Iterates through every brick in the array
            var brick = bricks[c][r]; //Stores each brick as brick
            if(brick.status == 1){
                if(x > brick.x && x < brick.x+brickWidth && y > brick.y && y < brick.y+brickHeight) { //If the ball is between the x and y values of the brick
                    brick.status = 0;  //brick is now destroyed
                    dy = -dy; //Changes direction
                    score++;
                    if(score == brickRowCount*brickColumnCount){
                        alert("CONGRATULATIONS, you have won!");
                        document.location.reload(); //reloads the page
                    }
                }
            }
        }
    }
 }

 function drawScore() {
    ctx.font = "16px Lucida Console";
    ctx.fillStyle = "#0095DD";
    ctx.fillText("Score: "+score, 8, 20);
 }
 function drawLives() {
    ctx.font = "16px Lucida Console";
    ctx.fillStyle = "#0095DD";
    ctx.fillText("Lives: "+lives, canvas.width-85, 20);
 }

 function drawBall() {
    //white circle with black outline
    ctx.beginPath();
    ctx.arc(x,y,ballRadius,0, Math.PI*2,false); //20 is the radius, 0 is the start angle in radians and Math.PI*2 is the end angle and false means draw anti-clockwise
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.stroke();
    ctx.closePath();
    x += dx;
    y += dy;
 }

 function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, paddleY, paddleWidth, paddleHeight);
    ctx.fillStyle = "blue";
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.stroke();
    ctx.closePath();
    if(rightPressed) {
        paddleX += 5;
        if (paddleX + paddleWidth > canvas.width){
            paddleX = canvas.width - paddleWidth;
        }
    }
    else if(leftPressed) {
        paddleX -= 5;
        if (paddleX < 0){
            paddleX = 0;
        }
    }
 }
 
 function drawBricks() {
    for(var c=0; c<brickColumnCount; c++) {
        for(var r=0; r<brickRowCount; r++) {
            if(bricks[c][r].status==1) { //Draw if brick hasn't been hit
                var brickX = (c*(brickWidth+brickPadding)) +brickOffsetLeft; //x coordinate is the column X width (including padding) + the offset 
                var brickY = (r*(brickHeight+brickPadding)) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                if(r==0){
                ctx.fillStyle = "#e82a43";
                }
                else if(r==1){
                ctx.fillStyle = "#1cd60f";
                }
                else{
                ctx.fillStyle = "#ebb821";
                }
                ctx.fill();
                ctx.closePath();
            }

        }
    }   
 }
 

 function bounce() {
    if(x + dx > canvas.width-ballRadius  || x + dx < ballRadius) { //If ball bounces off sides
        dx = -dx;
    }
        
    if(y + dy < ballRadius) { //If ball bounces off the top
        dy = -dy;            
    }
    else if(y + dy > canvas.height-ballRadius) { //If ball hits the bottom
        if(x > paddleX && x < paddleX + paddleWidth) { // If the x coordinate of the ball is between each end of the paddle it bounces
            dy = -dy;
        }
        else {
            lives--;
            if(!lives) {
                alert("GAME OVER");
                document.location.reload();
            }
            else { //If there are lives left the ball and paddle are reset
                x = canvas.width/2;
                y = canvas.height-30;
                dx = 2;
                dy = -2;
                paddleX = (canvas.width-paddleWidth)/2;
            }
        }
    }
          
 }


 function draw() {
    //clears screen so it doesn't leave a trail
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
    drawScore();
    drawLives();
    collisionDetection();
    bounce();
    requestAnimationFrame(draw);
 }
 
 

 
</script>

</body>
</html>